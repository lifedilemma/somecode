# --------------------------------------------
# parameters
# --------------------------------------------
THRESH = 0.003          # 0.30 % absolute move in the base pair
LAGS   = top            # list of (abs_corr, corr, base, target, lag) you computed earlier

# containers
sig = pd.DataFrame(index=rets_real.index)          # +1 / -1 / 0  signals
pl  = pd.Series(0.0,      index=rets_real.index)   # hourly PnL stream

# --------------------------------------------
# main loop with threshold filter
# --------------------------------------------
for abs_corr, corr, base, target, lag in LAGS:
    
    # 1. real hourly return of the base pair
    r_base = rets_real[f'px_{base}']
    
    # 2. trigger only if |return| > 0.30 %
    trigger = (r_base.abs() > THRESH)
    
    # 3. direction of the position we will open *immediately*
    pos = np.sign(r_base) * np.sign(corr)          # long or short
    pos = pos.where(trigger, 0)                    # zero if no trigger
    
    # 4. PnL = position * sum of target real returns over <lag> hours
    #    rolling(...).sum().shift(-(lag-1)) aligns exit at t+lag-1
    rolling_sum = (
        rets_real[f'px_{target}']
        .rolling(lag, min_periods=lag
        .sum()
        .shift(-(lag-1))
    )
    pnl = pos * rolling_sum
    
    # 5. store
    sig[f'{base}->{target}@{lag}h'] = pos
    pl += pnl.fillna(0)

cum = pl.cumsum()          # equity curve for dashboards










# prerequisites: rets_real, rets_log, top ([(abs_corr, corr, base, target, lag), ...])
import numpy as np
import pandas as pd

THRESH = 0.003          # 0.30 % trigger
sig     = pd.DataFrame(index=rets_log.index)   # +1 / –1 entry signals
pl      = pd.Series(0.0, index=rets_log.index)

for _, corr, base, target, lag in top:
    # 1. trigger flag
    trig = (rets_real[f'px_{base}'].abs() > THRESH).astype(int)

    # 2. signed entry (+1 long, –1 short)
    entry = np.sign(rets_real[f'px_{base}']) * np.sign(corr) * trig

    # 3. cumulative position size (overlapping trades stack)
    stack = entry.cumsum() - entry.cumsum().shift(lag).fillna(0)

    # 4. PnL: position at t times target’s sum of returns over [t, t+L-1]
    pnl = stack * (
        rets_real[f'px_{target}']
        .rolling(lag, min_periods=lag).sum()
        .shift(-(lag - 1))
    )

    sig[f'{base}->{target}@{lag}h'] = entry
    pl += pnl.fillna(0)

cum_equity = pl.cumsum()
